import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, RenderOptions } from '@testing-library/react';
import React, { ReactElement } from 'react';
import { TimelineView } from './TimelineView';
import { AppState } from '../../types';
import { HelpProvider } from '../../context/HelpContext';

// Helper to create a mock state with events
const createMockState = (events: AppState['events'], characters: AppState['characters'] = []): Partial<AppState> => ({
  events,
  characters,
  timeline: { edges: [] },
});

// Mock the useStore hook
const mockDispatch = vi.fn();
let mockState: Partial<AppState> = createMockState([]);

vi.mock('../../context/StoreContext', async () => {
  const actual = await vi.importActual('../../context/StoreContext');
  return {
    ...actual,
    useStore: () => ({
      state: mockState,
      dispatch: mockDispatch,
    }),
  };
});

const renderWithHelp = (ui: ReactElement, options?: RenderOptions) => {
  return render(ui, { wrapper: HelpProvider, ...options });
};

describe('TimelineView', () => {
  beforeEach(() => {
    mockDispatch.mockClear();
    // Suppress console logs during tests
    vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('Date Parsing', () => {
    it('should parse ISO format dates (yyyy-mm-dd)', () => {
      mockState = createMockState([
        { id: '1', title: 'Event 1', date: '2024-06-15', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show the event on timeline (not in undated section)
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should parse dd/mm/yyyy format dates', () => {
      mockState = createMockState([
        { id: '1', title: 'Event 1', date: '15/06/2024', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show event, not undated
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should parse dd/mm/yyyy hh:mm:ss format dates (app storage format)', () => {
      // This is the exact format the app stores dates in
      mockState = createMockState([
        { id: '1', title: 'Event 1', date: '15/06/2024 10:30:00', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show event, not undated
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should parse dates from Born/Died auto-events (dd/mm/yyyy 00:00:00)', () => {
      // This is the exact format generated by StoreContext for Born/Died events
      mockState = createMockState([
        { id: '1', title: 'Maria Born', date: '01/02/2000 00:00:00', characters: ['c1'] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show event, not undated
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should handle events without dates', () => {
      mockState = createMockState([
        { id: '1', title: 'Undated Event', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show undated section
      expect(screen.getByText('ðŸ“… Undated Events')).toBeInTheDocument();
    });

    it('should handle mixed dated and undated events', () => {
      mockState = createMockState([
        { id: '1', title: 'Dated Event', date: '2024-06-15', characters: [] },
        { id: '2', title: 'Undated Event', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show undated section for the undated event
      expect(screen.getByText('ðŸ“… Undated Events')).toBeInTheDocument();
      // Should have both "All Events" lane (1 dated) and "Undated Events" lane (1 undated)
      const eventCounts = screen.getAllByText('(1)');
      expect(eventCounts).toHaveLength(2);
    });

    it('should parse historical dates (1800s)', () => {
      mockState = createMockState([
        { id: '1', title: 'Old West Event', date: '1885-07-04', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should parse future dates (2200s)', () => {
      mockState = createMockState([
        { id: '1', title: 'Sci-Fi Event', date: '2250-12-25', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should parse historical dates in dd/mm/yyyy format (Old West)', () => {
      mockState = createMockState([
        { id: '1', title: 'Old West Event', date: '04/07/1885 00:00:00', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });

    it('should parse future dates in dd/mm/yyyy format (Sci-Fi)', () => {
      mockState = createMockState([
        { id: '1', title: 'Sci-Fi Event', date: '25/12/2250 00:00:00', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.queryByText('ðŸ“… Undated Events')).not.toBeInTheDocument();
    });
  });

  describe('Timeline Bounds', () => {
    it('should calculate bounds from event dates', () => {
      mockState = createMockState([
        { id: '1', title: 'Event 1', date: '2024-01-01', characters: [] },
        { id: '2', title: 'Event 2', date: '2024-12-31', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      // Should show date range info
      expect(screen.getByText(/Showing:/)).toBeInTheDocument();
    });

    it('should show empty state when no events', () => {
      mockState = createMockState([]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.getByText(/No events yet/)).toBeInTheDocument();
    });
  });

  describe('Character Lanes', () => {
    it('should show All Events lane when no character associations', () => {
      mockState = createMockState([
        { id: '1', title: 'Event 1', date: '2024-06-15', characters: [] },
      ]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.getByText('All Events')).toBeInTheDocument();
    });

    it('should create lanes for characters with events', () => {
      mockState = createMockState(
        [
          { id: 'e1', title: 'Event 1', date: '2024-06-15', characters: ['c1'] },
        ],
        [
          { id: 'c1', name: 'Hero', tags: [] },
        ]
      );

      renderWithHelp(<TimelineView />);
      
      expect(screen.getByText('Hero')).toBeInTheDocument();
    });
  });

  describe('UI Controls', () => {
    it('should render zoom controls', () => {
      mockState = createMockState([]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.getByTitle('Zoom In (Ctrl+Scroll)')).toBeInTheDocument();
      expect(screen.getByTitle('Zoom Out (Ctrl+Scroll)')).toBeInTheDocument();
      expect(screen.getByTitle('Reset Zoom')).toBeInTheDocument();
    });

    it('should render date range inputs', () => {
      mockState = createMockState([]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.getByText('From:')).toBeInTheDocument();
      expect(screen.getByText('To:')).toBeInTheDocument();
      expect(screen.getByText('Apply')).toBeInTheDocument();
      expect(screen.getByText('Fit')).toBeInTheDocument();
    });

    it('should render quick range buttons', () => {
      mockState = createMockState([]);

      renderWithHelp(<TimelineView />);
      
      expect(screen.getByText('1800s')).toBeInTheDocument();
      expect(screen.getByText('Â±50yr')).toBeInTheDocument();
      expect(screen.getByText('Future')).toBeInTheDocument();
    });
  });
});
